_boot:
	jmp.i $_start
_print:
	_print_start:
		pop r15
		pop r1 # Get pointer to data
		pop r2 # Get starting point
		push r15
		load r0, 0xF000	# Fixed VRAM addr
		# Add starting point to start of VRAM
		add r0, r0, r2

	# Check if byte is zero
	_print_zerocheck:
		load r3, 0x0000
		read.h r3, r1, 0x0
		test r3
		jz.i $_print_end
	
	# Print the character
	_print_byte:
		write.h r0, r3, 0x0 # Move byte into VRAM
		addi r0, r0, 0x1 # Increase VRAM pointer
		addi r1, r1, 0x1 # Increase data pointer
		jmp.i $_print_zerocheck

	# Stop printing
	_print_end:
			ret	

_clear:
	_clear_start:
		pop r15
		pop r1 # start
		pop r2 # length
		push r15
		load r3, 0x20 # space
		
		# Calc VRAM addr
		load r0, 0xF000	# Fixed VRAM addr
		add r1, r1, r0
	
	_clear_write:
		# Setup loop
		test r2
		jz.i $_clear_end
		subi r2, r2, 0x1

		# Write to VRAM
		write.l r1, r3, 0x0
		
		# Increase start
		addi r1, r1, 0x1
		
		jmp.i $_clear_write
		
	_clear_end:
		ret

_setcursor:
	_setcursor_start:
		pop r15
		pop r1 # cursor pos (0xAABB where AA is x pos and BB is y pos)
		push r15
		load r0, 0xED00 # Cursor x pos addr
	
	_setcursor_write:
		write.h r0, r1, 0x0 # Write x pos
		write.l r0, r1, 0x1 # Write y pos
	
	_setcursor_end:
		ret

_getinput:
	_getinput_start:
		load r0, 0xEF00
		load r1, 0x0000
	
	_getinput_read:
		read.l r1, r0, 0x0
	
	_getinput_end:
		pop r15
		push r1
		push r15
		ret
_int:
	ret

_getstring:
	_getstring_start:
		pop r15
		pop r5 # inputdata
		pop r7 # print offset
		mov r6, r5
		push r15

	_getstring_loop:
		# Get input
		call.i $_getinput
		pop r1
		mov r8, r1

		# Check for newline
		load r4, 0x0A # newline
		cmp r4, r1
		jne.i $_getstring_backspace

		# Write null byte at end of string
		load r1, 0x00
		write.l r5, r1, 0x0
		jmp.i $_getstring_end

	_getstring_backspace:
		# Check for backspace
		load r4, 0x08 # backspace
		cmp r4, r1
		jne.i $_getstring_write

		# Check that we're not on the first char
		cmp r5, r6
		jle.i $_getstring_loop

		# Delete last character if backspace was pressed
		subi r5, r5, 0x1
		load r2, 0x00
		write.l r5, r2, 0x0
		jmp.i $_getstring_print

	_getstring_write:
		# Write to RAM
		load r2, 0x0000
		write.l r5, r1, 0x0
		write.l r5, r2, 0x1 # write null byte to end string

	_getstring_print:
		# Clear previous string
		load r10, 0d80
		sub r10, r10, r7 # calc offset to EOL
		push r10
		push r7
		call.i $_clear

		# Call print
		push r7
		push r6
		call.i $_print

		# Jump to start of loop
		load r4, 0x08 # backspace
		cmp r4, r8
		# Don't do addition if backspace was pressed
		je.i $_getstring_loop
		addi r5, r5, 0x1
		jmp.i $_getstring_loop

	_getstring_end:
		# Clear previous string
		load r10, 0d80
		sub r10, r10, r7 # calc offset to EOL
		push r10
		push r7
		call.i $_clear

		ret

_strcmp:
	_strcmp_start:
		pop r15
		pop r1 # &str1
		pop r2 # &str2
		pop r3 # length
		push r15
	
	_strcmp_loop:
		# Check char
		read.l r5, r1, 0x0
		read.l r6, r2, 0x0
		cmp r5, r6
		jne.i $_strcmp_false

		# Go to next char
		addi r1, r1, 0x1
		addi r2, r2, 0x1

		# Setup loop
		subi r3, r3, 0x1
		load r4, 0x0
		cmp r3, r4
		jg.i $_strcmp_loop
	
	_strcmp_true:
		load r0, 0x0
		ret

	_strcmp_false:
		load r0, 0x1
		ret

_strlen:
	_strlen_start:
		pop r15
		pop r1 # str
		push r15
		load r0, 0x00 # counter
		load r2, 0x00

	_strlen_loop:
		# Check if current char is null
		read.l r2, r1, 0x0
		test r2
		jz.i $_strlen_end
		addi r0, r0, 0x1 # inc counter
		addi r1, r1, 0x1 # inc str
		jmp.i $_strlen_loop

	_strlen_end:
		ret
		
_code:
