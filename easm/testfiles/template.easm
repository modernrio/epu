_boot:
	jmp.i $_start
_print:
	_print_start:
		pop r15
		pop r1 # Get pointer to data
		pop r2 # Get starting point
		push r15
		load r0, 0xF000	# Fixed VRAM addr
		# Add starting point to start of VRAM
		add r0, r0, r2

	# Check if byte is zero
	_print_zerocheck:
		load r3, 0x0000
		read.h r3, r1, 0x0
		test r3
		jz.i $_print_end
	
	# Print the character
	_print_byte:
		write.h r0, r3, 0x0 # Move byte into VRAM
		addi r0, r0, 0x1 # Increase VRAM pointer
		addi r1, r1, 0x1 # Increase data pointer
		jmp.i $_print_zerocheck

	# Stop printing
	_print_end:
			ret	
_setcursor:
	_setcursor_start:
		pop r15
		pop r1 # cursor pos (0xAABB where AA is x pos and BB is y pos)
		push r15
		load r0, 0xED00 # Cursor x pos addr
	
	_setcursor_write:
		write.h r0, r1, 0x0 # Write x pos
		write.l r0, r1, 0x1 # Write y pos
	
	_setcursor_end:
		ret

_getinput:
	_getinput_start:
		load r0, 0xEF00
		load r1, 0x0000
	
	_getinput_read:
		read.l r1, r0, 0x0
	
	_getinput_end:
		pop r15
		push r1
		push r15
		ret
_int:
	ret

_getstring:
	_getstring_start:
		pop r15
		pop r5 # inputdata
		pop r7 # print offset
		mov r6, r5
		push r15

	_getstring_loop:
		# Get input
		call.i $_getinput

		# Write input to RAM
		pop r1
		load r2, 0x0000
		write.l r5, r1, 0x0
		write.l r5, r2, 0x1 # write null byte to end string
		load r4, 0x0A #newline
		cmp r4, r1
		je.i $_getstring_end

		# Call print
		push r7
		push r6
		call.i $_print

		# Jump to start of loop
		addi r5, r5, 0x1
		jmp.i $_getstring_loop

	_getstring_end:
		ret

_strcmp:
	_strcmp_start:
		pop r15
		pop r1 # &str1
		pop r2 # &str2
		pop r3 # length
		push r15
	
	_strcmp_loop:
		# Check char
		read.l r5, r1, 0x0
		read.l r6, r2, 0x0
		cmp r5, r6
		jne.i $_strcmp_false

		# Go to next char
		addi r1, r1, 0x1
		addi r2, r2, 0x1

		# Setup loop
		subi r3, r3, 0x1
		load r4, 0x0
		cmp r3, r4
		jg.i $_strcmp_loop
	
	_strcmp_true:
		load r0, 0x0
		ret

	_strcmp_false:
		load r0, 0x1
		ret
_code:
